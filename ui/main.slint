import { Button, ComboBox, TextEdit, Spinner, VerticalBox, LineEdit, TabWidget } from "std-widgets.slint"; 
export enum SelectedWindow { select, freestyle, story, blocks, levels }

struct BlockData {
    block_id: int,
    block_width: int,
    block_color: color,
    block_name: string,
    code: string,
    x: length,
    y: length,
}

export component Block inherits Rectangle{
    property <int> block_width;
    in property <color> block_color;
    in property <string> block_name;
    in property <string> code;
    in property <int> block_id;
    property <length> x_displacement;
    property <length> y_displacement;

    // BlockID, x, y
    callback move(length, length);
    
    clip: true;
    block_width: blockName.width / 1px;
    width: block_width * 1px + 106px;
    // width: blockName.width+ 100px;
    height: (75px)/2;
    z:500.0;
    
    Path {
        x:0;
        y:0;
        stroke: black;
        stroke-width: 3px;
        fill: block_color;
        MoveTo {x:0;y:(0)/3;}

        LineTo {x:15;y:(0)/3;}//indent
        LineTo {x:25;y:(20)/3;} 
        LineTo {x:45;y:(20)/3;}
        LineTo {x:55;y:(0)/3;}
        
        LineTo {x:95+block_width;y:(0)/3;}
        ArcTo {x:100+block_width;y:(5)/3; radius-x: 5; radius-y: 5; sweep: true;}
        LineTo {x:100+block_width;y:(95)/3;}
        ArcTo {x:95+block_width;y:(100)/3; radius-x: 5; radius-y: 5; sweep: true;}
        
        
        LineTo {x:55;y:(100)/3;}//outdent
        LineTo {x:45;y:(120)/3;}
        LineTo {x:25;y:(120)/3;}
        LineTo {x:15;y:(100)/3;}
        LineTo {x:5;y:(100)/3;}

        ArcTo {x:0;y:(95)/3; radius-x: 5; radius-y: 5; sweep: true;}
        LineTo {x:0;y:(5)/3;}
        ArcTo {x:0;y:(0)/2; radius-x: 5; radius-y: 5; sweep: true;}
        
    }
    


    blockName := Text {
        x:20px;
        text: block_name;
        color: black;
        font-family: "Comic Sans MS";
        font-weight: 550;
        font-size: 16px;
    }

    TouchArea {
        pointer-event(event) => {
            if(event.button==PointerEventButton.left){
                x_displacement = self.mouse-x;
                y_displacement = self.mouse-y;
            }
            
        }
        clicked => {
            debug("released");
            move(root.x, root.y);


        }
        moved => {
            if (self.pressed){
                parent.x += self.mouse-x - x_displacement;
                parent.y += self.mouse-y - y_displacement;
            }
        }
    }
}

enum MessageType {
    func_name,
    func_type,
    func_args,

    decl_type,
    decl_name,
    decl_expr,

    assign_name,
    assign_expr,

    expr_expr,

    return_expr,

    if_cond,

    if_else_cond,

    while_cond,

    none,
}

// for setting things like exprs automagically
export component PopUp inherits VerticalLayout {
    // in property <string> cur_message: "Default popup";
    property <MessageType> cur_message_type;
    callback send_message(MessageType, string);
    public function appear(mtype: MessageType, querytext: string) {
        self.visible = true;
        query.text = querytext;
        cur_message_type = mtype;
        input-field.text = "";
        input-field.enabled = true;
    }
    function disappear() {
        self.visible = false;
        send_message(cur_message_type, input-field.text);
        input-field.text = "";
        input-field.enabled = false;
    }
    visible: false;

    query := Text {
        text: "";
    }
    input_field := LineEdit {
        text: "";
        enabled: false;
        accepted => {
            disappear();
        }
    }
    submit_box := Button {
        text: "Submit";
        clicked => {
            disappear();
        }
    }
}

export component CodeArea inherits VerticalLayout {
    in property <string> start_text;
    
    in property <string> result: "Nothing yet";
    callback run_code(string);
    

    changed result => {
        spin.progress = 0%;
        spin.visible = false;
        spintime.running = false;
        result_text.text = result;
    }
    in property <length> parent_height;
    height: parent_height - self.y - startbutton.height ;
    spacing: 5px;

    spintime := Timer {
        interval: 50ms;
        running: false;
        triggered => {
            spin.progress += spin.progress >= 100% ? -100% : 2%;
        }
    }
    

    editor := TextEdit {
        min-width: 300px;
        min-height: 300px;
        font-size: 14px;
        // has-focus: true;

        text: start_text;
    }
    startbutton := Button {
        height: 30px;
        text: "Start";
        clicked => {
            spintime.running = true;
            spin.visible = true;
            run_code(editor.text);
        }
    }
    result_text := Text {
        text: "Nothing yet";
    }
    spin := Spinner {
        visible: false;
        progress: 0%;
    }

}
/*
component test {
    Rectangle {
        property <int> widthy;
        widthy: 200;
        width: 200px;
        height: 200px;
        Path {
            stroke: black;
            stroke-width: 3px;
            fill: darkorange;
            MoveTo {x:5;y:0;}

            LineTo {x:30;y:0;}//indent
            LineTo {x:40;y:20;} 
            LineTo {x:90;y:20;}
            LineTo {x:100;y:0;}
            
            LineTo {x:95+widthy;y:0;}
            ArcTo {x:100+widthy;y:5; radius-x: 5; radius-y: 5; sweep: true;}
            LineTo {x:100+widthy;y:95;}
            ArcTo {x:95+widthy;y:100; radius-x: 5; radius-y: 5; sweep: true;}
           
           
            LineTo {x:100;y:100;}//outdent
            LineTo {x:90;y:120;}
            LineTo {x:40;y:120;}
            LineTo {x:30;y:100;}
            LineTo {x:5;y:100;}
            ArcTo {x:0;y:95; radius-x: 5; radius-y: 5; sweep: true;}
            LineTo {x:0;y:5;}
            ArcTo {x:5;y:0; radius-x: 5; radius-y: 5; sweep: true;}
            
        }
    }
}

*/
component SelectionScreen {
    callback freestyleClick <=> fm.clicked;
    callback storyClick <=> sm.clicked;
    callback blockClick <=> b.clicked;
    min-width: 350px;
    Rectangle {
        VerticalLayout {
            width: 100%;
            height: 30%;
            alignment: end;
            Text {
                text: "Welcome to Prism Private Intelligence!";
                horizontal-alignment: center;
            }
            Text {
                text: "The Premier Learn-To-Code App utilizing Mediated Transfer!";
                horizontal-alignment: center;
                min-height: 50px;
                wrap: word-wrap;
            }
            Rectangle {
                
                fm := Button {
                    x: parent.width/2 - sm.width/2 - fm.width - 5px;
                    text: "Freestyle Mode";
                }
                sm := Button {
                    x: parent.width/2 - sm.width/2;
                    text: "Story Mode";
                }
                b := Button {
                    x: parent.width/2 + sm.width/2 +5px;
                    text: "Blocks";
                }
            }
            // HorizontalLayout {
            //     padding-top: 50px;
            //     padding-left: 10px;
            //     padding-right: 10px;
            //     height: 30%;
            //     spacing: 5px;
                
            //     fm := Button {
            //         text: "Freestyle Mode";
            //     }
            //     sm := Button {
            //         text: "Story Mode";
            //     }
            //     cl := Button {
            //         text: "Custom Levels";
            //     }
            // }
        }
    }
    Image {
        image-fit: preserve;
        y:parent.height - self.height;
        width: 100%;
        vertical-alignment: bottom;
        source: @image-url("images/tiling_city.png");
        horizontal-tiling: repeat;
    }
}

enum SlintBlockType {
    function,
    declaration,
    assignment,
    expression,
    return,
    if_blk,
    else_blk,
    while_blk,
}

component LevelScreen {
    in property <string> start_text;
    in property <string> problem;
    in property <string> result <=> codeArea.result;
    callback test_code <=> codeArea.run_code;
    callback back_button <=> back.clicked;

    problem: "do fibonocci or someone dies, be a good detective or else";
    back := Button {
        width: 50px;
        height: 50px;
        primary: false;
        text: "<-";
        x: 5px;
        y: 5px;
    }
    minimizeBlocks := Button {
        y:5px + back.height +5px;
        x:5px;
        width: 50px;
        height: 50px;
        text: "[=]";
        clicked => {
            if (problemText.width > 0px){
                problemText.width = 0px;
            }
            else{
                problemText.width = 300px;
            }
        }
    }
    problemText := Rectangle {
        x: 60px;
        y:5px;
        height: parent.height - 10px;
        width: 300px;
        background: gray;
        border-radius: 5px;
        Text {
            y:5px;
            x:5px;
            font-size: 15px;
            wrap: word-wrap;
            width: parent.width;
            text: problem;
            color: black;
        }
    }
    codeArea := CodeArea {
        x: 5px + back.width + 5px + problemText.width + 5px;
        y: 5px;
        parent_height: parent.height;
        width: parent.width - self.x - 5px;
        start_text: start_text;
    }
}

component FreestyleScreen{
    in property <string> result <=> codeArea.result;
    callback run_code <=> codeArea.run_code;
    callback create_block(SlintBlockType);
    // BlockID, x, y, x displacement, y displacement
    callback move_block(int, length, length);
    callback back_button <=> back.clicked;
    callback send_message <=> popup.send_message;
    public function appear_message(mtype: MessageType, querytext: string) {
        popup.appear(mtype, querytext);
    }

    
    
    back := Button {
        width: 50px;
        height: 50px;
        primary: false;
        text: "<-";
        x: 5px;
        y: 5px;
    }

    // minimizeBlocks := Button {
    //     y:5px + back.height +5px;
    //     x:5px;
    //     width: 50px;
    //     height: 50px;
    //     text: "[=]";
    //     clicked => {
    //         if (blockArea.width == 150px){
    //             blockArea.width = 0px;
    //         }
    //         else{
    //             blockArea.width = 150px;
    //         }
    //     }
    // }

    in property <[BlockData]> blocks: [
        // {block_id: 1,block_width:10, block_color:Colors.orange, block_name:"Test block",code:"example 1",x:0px,y:0px},
        // {block_id: 2,block_width:100, block_color:Colors.orange, block_name:"Test block 2",code:"example 2",x:300px,y:300px}
    ];

    codeArea := CodeArea {
        x: 5px + back.width + 5px;
        y: 5px;
        width: parent.width - self.x - 5px - blockArea.width - 5px;
        parent_height: parent.height;
    }

    
    //block area
    
    popup := PopUp {
        width: 50%;
        height: 50%;
    }

    
    Rectangle {
        x: 5px + back.width + 5px + codeArea.width + 5px;
        y: 5px;
        width: 160px;

        blockArea := Rectangle{
            width: 0px;
            height: parent.height - 130px;
            y:0px;
            x:0px;
            background: gray;
            border-width: 5px;
            
            Button {
                text: "spawn expression block";
                y:5px;
                x:5px;
                clicked => {
                    create_block(SlintBlockType.expression);
                }
            }   
            Button {
                text: "spawn declaration block";
                x:5px;
                y:40px;
                clicked => {
                    create_block(SlintBlockType.declaration);
                }
            }   

        }
        logo:=Image {
            y: parent.height - blockArea.width + 35px - 5px;
            width: blockArea.width - 40px;
            height: blockArea.width - 40px;
            source: @image-url("images/Prism-P.I._logo_temp.png");
        }
    }
    
    for block[i] in blocks : Block{
        // block_width: block.block_width;
        block_color: block.block_color;
        block_name: block.block_name;
        x: block.x;
        y: block.y;
        block_id: block.block_id;
        move(x, y) => {
            move_block(self.block_id, x, y);
        }
    }

}

component BlockScreen {
    callback back_button <=> back.clicked;
    callback create_block(SlintBlockType);
    callback move_block(int, length, length);
    callback send_message <=> popup.send_message;

    public function appear_message(mtype: MessageType, querytext: string) {
        popup.appear(mtype, querytext);
    }


    in property <[BlockData]> blocks: [];
    back := Button {
        width: 50px;
        height: 50px;
        primary: false;
        text: "<-";
        x: 5px;
        y: 5px;
    }
    
    minimizeBlocks := Button {
        y:5px + back.height +5px;
        x:5px;
        width: 50px;
        height: 50px;
        text: "[=]";
        clicked => {
            if (blockArea.width > 0px){
                blockArea.width = 0px;
                // declarationButton.x = 300px;
            }
            else{
                blockArea.width = 200px;
                // declarationButton.x  = 5px;
            }
        }
    }
    
    blockArea := Rectangle {
        x: parent.width - 205px;
        y: 5px;
        width: 200px;

        Rectangle{
            height: parent.height - logo.height - 10px;
            y:0px;
            x:0px;
            background: gray;
            border-width: 5px;

            Rectangle {
                height: (75px)/2;
                y:5px;
                Path {
                    x:0;
                    y:0;
                    stroke: black;
                    stroke-width: 3px;
                    fill: red;
                    MoveTo {x:0;y:(0)/3;}

                    LineTo {x:15;y:(0)/3;}//indent
                    LineTo {x:25;y:(20)/3;} 
                    LineTo {x:45;y:(20)/3;}
                    LineTo {x:55;y:(0)/3;}
                    
                    LineTo {x:95+50;y:(0)/3;}
                    ArcTo {x:100+50;y:(5)/3; radius-x: 5; radius-y: 5; sweep: true;}
                    LineTo {x:100+50;y:(95)/3;}
                    ArcTo {x:95+50;y:(100)/3; radius-x: 5; radius-y: 5; sweep: true;}
                    
                    
                    LineTo {x:55;y:(100)/3;}//outdent
                    LineTo {x:45;y:(120)/3;}
                    LineTo {x:25;y:(120)/3;}
                    LineTo {x:15;y:(100)/3;}
                    LineTo {x:5;y:(100)/3;}

                    ArcTo {x:0;y:(95)/3; radius-x: 5; radius-y: 5; sweep: true;}
                    LineTo {x:0;y:(5)/3;}
                    ArcTo {x:0;y:(0)/2; radius-x: 5; radius-y: 5; sweep: true;}
                    
                }
                TouchArea {
                    pointer-event(event) => {
                        if(event.button==PointerEventButton.left){
                            create_block(SlintBlockType.expression);
                        }
                        
                    }
                }
            }
            
            Rectangle {
                height: (75px)/2;
                y:45px;
                Path {
                    x:0;
                    y:0;
                    stroke: black;
                    stroke-width: 3px;
                    fill: orange;
                    MoveTo {x:0;y:(0)/3;}

                    LineTo {x:15;y:(0)/3;}//indent
                    LineTo {x:25;y:(20)/3;} 
                    LineTo {x:45;y:(20)/3;}
                    LineTo {x:55;y:(0)/3;}
                    
                    LineTo {x:95+50;y:(0)/3;}
                    ArcTo {x:100+50;y:(5)/3; radius-x: 5; radius-y: 5; sweep: true;}
                    LineTo {x:100+50;y:(95)/3;}
                    ArcTo {x:95+50;y:(100)/3; radius-x: 5; radius-y: 5; sweep: true;}
                    
                    
                    LineTo {x:55;y:(100)/3;}//outdent
                    LineTo {x:45;y:(120)/3;}
                    LineTo {x:25;y:(120)/3;}
                    LineTo {x:15;y:(100)/3;}
                    LineTo {x:5;y:(100)/3;}

                    ArcTo {x:0;y:(95)/3; radius-x: 5; radius-y: 5; sweep: true;}
                    LineTo {x:0;y:(5)/3;}
                    ArcTo {x:0;y:(0)/2; radius-x: 5; radius-y: 5; sweep: true;}
                    
                }
                TouchArea {
                    pointer-event(event) => {
                        if(event.button==PointerEventButton.left){
                            create_block(SlintBlockType.declaration);
                        }
                        
                    }
                }
            }

        }
        logo:=Image {
            y: parent.height - blockArea.width + 35px - 5px;
            width: blockArea.width - 40px;
            height: blockArea.width - 40px;
            source: @image-url("images/Prism-P.I._logo_temp.png");
        }
    }

    for block[i] in blocks : Block{
        // block_width: block.block_width;
        block_color: block.block_color;
        block_name: block.block_name;
        x: block.x;
        y: block.y;
        block_id: block.block_id;
        move(x, y) => {
            move_block(self.block_id, x, y);
        }
    }

    popup := PopUp {
        width: 300px;
        height: 75px;
    }
}
component StoryScreen {
    y:0;
    x:0;
    callback back_button <=> back.clicked;
    callback to_levels <=> storybtn.clicked;
    back := Button {
        width: 50px;
        height: 50px;
        primary: false;
        text: "<-";
        x: 5px;
        y: 5px;
    }
    Image {
        image-fit: contain;
        height: 100%;
        width: 100%;
        source: @image-url("images/map.png");

    }
    storybtn := Button {
        text: "go to the levels!";
    }
}

export component MainWindow inherits Window {
    title: "Prism-P.I.";
    min-height: 300px;
    min-width: 300px;
    property <SelectedWindow> windowToSelect: SelectedWindow.select;
    in property <string> freestyle_string <=> fs.result;
    callback run_freestyle_code <=> fs.run_code;

    callback run_hello_one_test <=> hello-one.test_code;
    in property <string> hello_one_result <=> hello-one.result;
    callback run_average_nums_test <=> average-nums.test_code;
    in property <string> average_nums_result <=> average-nums.result;
    callback run_fibonacci_test(string);

    in property <[BlockData]> blocks <=> bs.blocks;
    callback summon_block <=> bs.create_block;
    callback move_fs_block <=> bs.move_block;

    callback send_message_freestyle <=> fs.send_message;
    callback send_message_blocks <=> bs.send_message;
    public function freestyle_popup_appear(mtype: MessageType, querytext: string) {
        debug("Message to popup: ", querytext);
        bs.appear_message(mtype, querytext);
    }
    ss := SelectionScreen {
        width: 100%;
        height: 100%;
        visible: windowToSelect == SelectedWindow.select ? true : false;
        freestyleClick => {
            windowToSelect = SelectedWindow.freestyle;
        }
        storyClick => {
            windowToSelect = SelectedWindow.story;
        }
        blockClick => {
            windowToSelect = SelectedWindow.blocks;
        }
    }
    fs := FreestyleScreen {
        width: 100%;
        height: 100%;
        visible: windowToSelect == SelectedWindow.freestyle ? true : false;
        back_button => {
            windowToSelect = SelectedWindow.select;
        }
    }
    bs := BlockScreen {
        width: 100%;
        height: 100%;
        visible: windowToSelect == SelectedWindow.blocks ? true : false;
        back_button => {
            windowToSelect = SelectedWindow.select;
        }
    }
    ts := StoryScreen {
        width: 100%;
        height: 100%;
        visible: windowToSelect == SelectedWindow.story ? true : false;
        back_button => {
            windowToSelect = SelectedWindow.select;
        }
        to_levels => {
            windowToSelect = SelectedWindow.levels;
        }
    }
    levels := TabWidget {
        visible: windowToSelect == SelectedWindow.levels ? true : false;
        width: 100%;
        height: 100%;
        Tab {
            title: "Hello One";
            hello_one := LevelScreen {
                width: 100%;
                height: 100%;
                visible: windowToSelect == SelectedWindow.levels ? true : false;
                problem: "Hello, you're the new investigator, right? Ugh, now I have to go through the whole "
                    + "training thing yet again. Well, no better place to start than right now, right? "
                    + "Just to test your skills, we should see how good you are at making code, which is a "
                    + "vital part of our job at Prism Private Intelligence. We have a function laid out for you, "
                    + "declared with the keyword 'fun', with a name, and some silly parenthesis. Sometimes there "
                    + "will be some extra stuff in those parenthesis, sometimes not. Our people on the ground need "
                    + "to analyze the data they recieve on the ground, but they recieve so much, we cannot do "
                    + "all of it by hand, which is why we need you. For this one, I just need you to return the "
                    + "number '1'. That is it. To return an answer, literally all you need to write is "
                    + "'return {};' in the brackets of the function, where {} is any data. "
                    + "\n\nAre you up for this task?";
                // result: "The result of the tests will show up here.";
                back_button => {
                    windowToSelect = SelectedWindow.select;
                }
                start_text: "fun helloOne() -> int {\n    \n}";
            }
        }
        Tab {
            title: "Average Numbers";
            average_nums := LevelScreen {
                width: 100%;
                height: 100%;
                problem: "Average two numbers! And, they're both decimal values!";
                back_button => {
                    windowToSelect = SelectedWindow.select;
                }
                start_text: "fun averageDecimals(dcml num1, dcml num2) -> dcml {\n    \n}";
            }
        }
    }


}

