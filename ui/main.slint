import { Button, ComboBox, TextEdit, Spinner, VerticalBox, LineEdit } from "std-widgets.slint"; 
export enum SelectedWindow { select, freestyle, story, customlvl }

struct BlockData {
    block_id: int,
    block_width: int,
    block_color: color,
    block_name: string,
    code: string,
    x: length,
    y: length,
}

export component Block inherits Rectangle{
    in property <int> block_width;
    in property <color> block_color;
    in property <string> block_name;
    in property <string> code;
    in property <int> block_id;
    property <length> x_displacement;
    property <length> y_displacement;

    // BlockID, x, y
    callback move(length, length);
    
    clip: true;
    width: block_width * 1px + 106px;
    height: (75px)/2;
    z:500.0;
    
    Path {
        x:0;
        y:0;
        stroke: black;
        stroke-width: 3px;
        fill: block_color;
        MoveTo {x:5;y:(0)/3;}

        LineTo {x:15;y:(0)/3;}//indent
        LineTo {x:25;y:(20)/3;} 
        LineTo {x:45;y:(20)/3;}
        LineTo {x:55;y:(0)/3;}
        
        LineTo {x:95+block_width;y:(0)/3;}
        ArcTo {x:100+block_width;y:(5)/3; radius-x: 5; radius-y: 5; sweep: true;}
        LineTo {x:100+block_width;y:(95)/3;}
        ArcTo {x:95+block_width;y:(100)/3; radius-x: 5; radius-y: 5; sweep: true;}
        
        
        LineTo {x:55;y:(100)/3;}//outdent
        LineTo {x:45;y:(120)/3;}
        LineTo {x:25;y:(120)/3;}
        LineTo {x:15;y:(100)/3;}
        LineTo {x:5;y:(100)/3;}

        ArcTo {x:0;y:(95)/3; radius-x: 5; radius-y: 5; sweep: true;}
        LineTo {x:0;y:(5)/3;}
        ArcTo {x:5;y:(0)/2; radius-x: 5; radius-y: 5; sweep: true;}
        
    }
    


    Text {
        x:20px;
        text: block_name;
        color: black;
        font-family: "Comic Sans MS";
        font-weight: 550;
        font-size: 16px;
    }

    TouchArea {
        pointer-event(event) => {
            if(event.button==PointerEventButton.left){
                x_displacement = self.mouse-x;
                y_displacement = self.mouse-y;
            }
            
        }
        clicked => {
            debug("released");
            move(root.x, root.y);


        }
        moved => {
            if (self.pressed){
                parent.x += self.mouse-x - x_displacement;
                parent.y += self.mouse-y - y_displacement;
            }
        }
    }
}

enum MessageType {
    func_name,
    func_type,
    func_args,

    decl_type,
    decl_name,
    decl_expr,

    assign_name,
    assign_expr,

    expr_expr,

    return_expr,

    if_cond,

    if_else_cond,

    while_cond,

    none,
}

// for setting things like exprs automagically
export component PopUp inherits VerticalLayout {
    // in property <string> cur_message: "Default popup";
    property <MessageType> cur_message_type;
    callback send_message(MessageType, string);
    public function appear(mtype: MessageType, querytext: string) {
        self.visible = true;
        query.text = querytext;
        cur_message_type = mtype;
        input-field.text = "";
        input-field.enabled = true;
    }
    function disappear() {
        self.visible = false;
        send_message(cur_message_type, input-field.text);
        input-field.text = "";
        input-field.enabled = false;
    }
    visible: false;

    query := Text {
        text: "";
    }
    input_field := LineEdit {
        text: "";
        enabled: false;
        accepted => {
            disappear();
        }
    }
    submit_box := Button {
        text: "Submit";
        clicked => {
            disappear();
        }
    }
}

export component CodeArea inherits VerticalLayout {
    
    in property <string> result: "Nothing yet";
    callback run_code(string);
    

    changed result => {
        spin.progress = 0%;
        spin.visible = false;
        spintime.running = false;
        result_text.text = result;
    }
    in property <length> parent_height;
    height: parent_height - self.y - startbutton.height ;
    spacing: 5px;

    spintime := Timer {
        interval: 50ms;
        running: false;
        triggered => {
            spin.progress += spin.progress >= 100% ? -100% : 2%;
        }
    }
    

    editor := TextEdit {
        min-width: 300px;
        min-height: 300px;
        font-size: 14px;
        has-focus: true;

        text: "Write code here";
    }
    startbutton := Button {
        height: 30px;
        text: "Start";
        clicked => {
            spintime.running = true;
            spin.visible = true;
            run_code(editor.text);
        }
    }
    result_text := Text {
        text: "Nothing yet";
    }
    spin := Spinner {
        visible: false;
        progress: 0%;
    }

}

component test {
    Rectangle {
        property <int> widthy;
        widthy: 200;
        width: 200px;
        height: 200px;
        Path {
            stroke: black;
            stroke-width: 3px;
            fill: darkorange;
            MoveTo {x:5;y:0;}

            LineTo {x:30;y:0;}//indent
            LineTo {x:40;y:20;} 
            LineTo {x:90;y:20;}
            LineTo {x:100;y:0;}
            
            LineTo {x:95+widthy;y:0;}
            ArcTo {x:100+widthy;y:5; radius-x: 5; radius-y: 5; sweep: true;}
            LineTo {x:100+widthy;y:95;}
            ArcTo {x:95+widthy;y:100; radius-x: 5; radius-y: 5; sweep: true;}
           
           
            LineTo {x:100;y:100;}//outdent
            LineTo {x:90;y:120;}
            LineTo {x:40;y:120;}
            LineTo {x:30;y:100;}
            LineTo {x:5;y:100;}
            ArcTo {x:0;y:95; radius-x: 5; radius-y: 5; sweep: true;}
            LineTo {x:0;y:5;}
            ArcTo {x:5;y:0; radius-x: 5; radius-y: 5; sweep: true;}
            
        }
    }
}


component SelectionScreen {
    callback freestyleClick <=> fm.clicked;
    callback storyClick <=> sm.clicked;
    callback customClick <=> cl.clicked;
    min-width: 350px;
    Rectangle {
        VerticalLayout {
            width: 100%;
            height: 30%;
            alignment: end;
            Text {
                text: "Welcome to Prism Private Intelligence!";
                horizontal-alignment: center;
            }
            Text {
                text: "The Premier Learn-To-Code App utilizing Mediated Transfer!";
                horizontal-alignment: center;
                min-height: 50px;
                wrap: word-wrap;
            }
            Rectangle {
                
                fm := Button {
                    x: parent.width/2 - sm.width/2 - fm.width - 5px;
                    text: "Freestyle Mode";
                }
                sm := Button {
                    x: parent.width/2 - sm.width/2;
                    text: "Story Mode";
                }
                cl := Button {
                    x: parent.width/2 + sm.width/2 +5px;
                    text: "Custom Levels";
                }
            }
            // HorizontalLayout {
            //     padding-top: 50px;
            //     padding-left: 10px;
            //     padding-right: 10px;
            //     height: 30%;
            //     spacing: 5px;
                
            //     fm := Button {
            //         text: "Freestyle Mode";
            //     }
            //     sm := Button {
            //         text: "Story Mode";
            //     }
            //     cl := Button {
            //         text: "Custom Levels";
            //     }
            // }
        }
    }
    Image {
        image-fit: preserve;
        y:parent.height - self.height;
        width: 100%;
        vertical-alignment: bottom;
        source: @image-url("images/tiling_city.png");
        horizontal-tiling: repeat;
    }
}

enum SlintBlockType {
    function,
    declaration,
    assignment,
    expression,
    return,
    if_blk,
    else_blk,
    while_blk,
}

component FreestyleScreen{
    in property <string> result <=> codeArea.result;
    callback run_code <=> codeArea.run_code;
    callback create_block(SlintBlockType);
    // BlockID, x, y, x displacement, y displacement
    callback move_block(int, length, length);
    callback back_button <=> back.clicked;
    callback send_message <=> popup.send_message;
    public function appear_message(mtype: MessageType, querytext: string) {
        popup.appear(mtype, querytext);
    }

    
    

    back := Button {
        width: 50px;
        height: 50px;
        primary: false;
        text: "<-";
        x: 5px;
        y: 5px;
    }

    minimizeBlocks := Button {
        y:5px + back.height +5px;
        x:5px;
        width: 50px;
        height: 50px;
        text: "[=]";
        clicked => {
            if (blockArea.width == 150px){
                blockArea.width = 0px;
            }
            else{
                blockArea.width = 150px;
            }
        }
    }

    in property <[BlockData]> blocks: [
        {block_id: 1,block_width:10, block_color:Colors.orange, block_name:"Test block",code:"example 1",x:0px,y:0px},
        {block_id: 2,block_width:100, block_color:Colors.orange, block_name:"Test block 2",code:"example 2",x:300px,y:300px}
    ];

    codeArea := CodeArea {
        x: 5px + back.width + 5px;
        y: 5px;
        width: parent.width - self.x - 5px - blockArea.width - 5px;
        parent_height: parent.height;
        
    }

    
    //block area
    
    popup := PopUp {
        width: 50%;
        height: 50%;
    }

    
    Rectangle {
        x: 5px + back.width + 5px + codeArea.width + 5px;
        y: 5px;
        width: 160px;

        blockArea := Rectangle{
            width: 150px;
            height: parent.height - 130px;
            y:0px;
            x:0px;
            background: gray;
            border-width: 5px;
            
            Button {
                text: "spawn expression block";
                y:5px;
                x:5px;
                clicked => {
                    create_block(SlintBlockType.expression);
                }
            }   
            Button {
                text: "spawn declaration block";
                x:5px;
                y:40px;
                clicked => {
                    create_block(SlintBlockType.declaration);
                }
            }   

        }
        logo:=Image {
            y: parent.height - blockArea.width + 35px - 5px;
            width: blockArea.width - 40px;
            height: blockArea.width - 40px;
            source: @image-url("images/Prism-P.I._logo_temp.png");
        }
    }
    
    for block[i] in blocks : Block{
        block_width: block.block_width;
        block_color: block.block_color;
        block_name: block.block_name;
        x: block.x;
        y: block.y;
        block_id: block.block_id;
        move(x, y) => {
            move_block(self.block_id, x, y);
        }
    }

}

component CustomLevelScreen {
    Rectangle {
        Text { text: "Pretty custom yo"; }
    }
}





export component MainWindow inherits Window {
    title: "Prism-P.I.";
    min-height: 300px;
    min-width: 300px;
    property <SelectedWindow> windowToSelect: SelectedWindow.freestyle;
    in property <string> freestyle_string <=> fs.result;
    callback run_freestyle_code <=> fs.run_code;

    in property <[BlockData]> blocks <=> fs.blocks;
    callback summon_block <=> fs.create_block;
    callback move_fs_block <=> fs.move_block;
    callback send_message_freestyle <=> fs.send_message;
    public function freestyle_popup_appear(mtype: MessageType, querytext: string) {
        debug("Message to popup: ", querytext);
        fs.appear_message(mtype, querytext);
    }
    ss := SelectionScreen {
        width: 100%;
        height: 100%;
        visible: windowToSelect == SelectedWindow.select ? true : false;
        freestyleClick => {
            windowToSelect = SelectedWindow.freestyle;
        }
        storyClick => {
            windowToSelect = SelectedWindow.story;
        }
        customClick => {
            windowToSelect = SelectedWindow.customlvl;
        }
    }
    fs := FreestyleScreen {
        width: 100%;
        height: 100%;
        visible: windowToSelect == SelectedWindow.freestyle ? true : false;
        back_button => {
            windowToSelect = SelectedWindow.select;
        }
    }
    cs := CustomLevelScreen {
        visible: windowToSelect == SelectedWindow.customlvl ? true : false;
    }


}

